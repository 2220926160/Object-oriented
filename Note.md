## 面向对象程序设计教程（C++语言描述）

### 第3章  类与对象

##### 3.2 对象

##### 3.3 构造函数与析构函数

###### 3.3.1 构造函数

作用：对象的创建和初始化。

格式：

```c++
<类名>::<类名>(<形参表>)
{
	<函数体>
}

<类名>::<类名>()
{
}
```

特点：

- 它的函数名与类名相同。

- 它可以重载。

- 不能指定返回类型，即使是void类型也不可以。

- 它不能被显示调用，在创建对象的时候被自动调用。


###### 3.3.2 析构函数

作用：在对象消失时执行一项清理任务。

格式：

```c++
<类名>::~<类名>()
{
	<函数体>
}

<类名>::~<类名>()
{
}
```

特点：

- 析构函数的名字同类名，与构造函数名的区别在于析构函数名前加“~”，表明他的功能与构造函数的功能相反。

- 析构函数没有参数，不能重载，一个类中只能定义一个析构函数。

- 不能指定返回类型，即使是void类型也不可以。

- 析构函数在释放一个对象时候被自动调用。与构造函数不同的是，它能被显式调用，但不提倡。 

- 析构函数的调用顺序与构造函数的调用顺序相反。


###### 3.3.3 拷贝构造函数

作用：用一个已存在的对象去初始化另一个对象，为了保证所引用的对象不被修改，通常把引用参数声明为const参数。

格式：

```C++
<类名>::<类名>(const<类名>&<对象名>)
{
	<函数体>
}
```

特点：

• 

• 

• 

##### 3.4 this指针

作用：当创建一个对象时，this指针就初始化指向该对象。当某一对象调用一个成员函数时，this指针将作为一个变量自动传给该函数。

特点：

• this指针不能被显式调用。

• this指针是一个常量，不能作为赋值、递增、递减等运算的目标对象。

• 只有非静态类成员函数才拥有this指针，并通过该指针来处理对象。

• this指针只能在成员函数中使用（反元函数、全局函数不是成员函数）。

##### 3.5 子对象和堆对象

###### 3.5.1 子对象

声明：

```c++
class<X>{
		...
	<类名 1>	<子对象 1>
	<类名 2>	<子对象 2>
		...
	<类名 n>	<子对象 n>
};
```

初始化：X类的构造函数的定义形式如下

```c++
<X>::<X>(<参数表0>):<成员1>(<参数表1>),...,<成员0>(<参数表n>)
{
	...
}
```

特点：

- 对子对象的构造函数的调用顺序取决于这些子对象在类中说明的顺序，与它们在成员初始化列表中给出的顺序无关。

###### 3.5.2 堆对象

C++程序内存分区：

- 数据区(Data Area)
- 代码区(Code Area)
- 栈区(Stack Area)
- 堆区(及自有存储区)(Heap Area)

1. 使用运算符new创建堆对象

```c++
new<类型说明符>(<初始值列表>)
```

2. 使用运算符delete删除堆对象

```c++
delete<指针名>
```

3. 使用new[]创建对象数组

```c++
new<类型说明符>[<算术表达式>]
```

- 其中<算术表达式>给出数组的大小，后面不能再跟构造函数参数，所以，从对上分配对象数组，只能调用默认的构造函数，不能调用其他任何构造函数。

4. 使用delete[]删除对象数组

```c++
delete[]<指针名>
```

- 运算符delete[]必须用于有运算符new[]返回的指针。
- 对一个指针只能使用一次运算符delete[]。
- 指针名前只能用一对方括号，而不管所释放数组的维数，并且在方括号内不能写任何东西。
- 该运算符也适用于空指针。

##### 3.6 类的静态成员

### 第4章 继承机制

#### 5.3 成员函数中调用虚函数

- 一个基类或派生类的成员函数中可以直接调用该类等级中的虚函数。

- 在满足共有继承情况下，成员函数中调用函数将采用动态联编。

  ```c++
  // 【例5.8】
  // 输出结果：This is Subclass func1
  
  #include<iostream>
  
  using namespace std;
  
  class Base
  {
  public:
      virtual void func1()
      {
          cout<<"This is Base func1"<<endl;
      }
      void func2(){func1();}
  };
  class Subclass:public Base
  {
      virtual void func1()
      {
          cout<<"This is Subclass func1"<<endl;
      }
  };
  int main()
  {
      Subclass sc;
      sc.func2();
      return 0;
  }
  ```

  #### 5.4 构造函数和析构函数中调用虚函数

### 第5章 多态性和虚函数

### 第6章 运算符重载

### 第7章 模板







